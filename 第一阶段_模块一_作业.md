###一、简单题

####1、Mybatis动态sql是做什么的？都有哪些动态sql？简述一下动态sql的执行原理？
**动态sql**
mybatis的动态sql是让我们在xml文件中，以xml标签形式编写动态sql，完成逻辑判断和动态拼接sql的功能。
**有九种动态sql标签：**
if、choose、when、otherwise、trim、where、set、foreach、bind。
**原理：**
是使用OGNL的表达式，从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，来完成动态sql执行的功能。

####2、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？
支持延迟加载
原理：使用cglib创建目标对象的代理对象。
使用场景：
多对一、一对一通常使用立即加载
一对多、多对多通常使用延迟加载

####3、Mybatis都有哪些Executor执行器？它们之间的区别是什么？
Executor是一个接口，有三个常用实现类。
SimpleExecutor，普通执行器，默认使用。每次执行update或select都开启一个statement对象，用完立即关闭
BatchExecutor，批量执行器，缓存多个statement对象，统一执行update	
ReuseExecutor，重用预处理语句，用完后不关闭statement对象，供下一次使用。

####4、简述下Mybatis的一级、二级缓存（分别从存储结构、范围、失效场景。三个方面来作答）？
**存储结构：**
一级缓存是用的数据结构是HashMap。
二级缓存默认是使用PerpetualCache实现的，底层和一级缓存一样，也是HashMap实现的。当使用分布式缓存，比如Redis时，存储的数据结构是hash

**范围：**
一级缓存是SqlSession级别的缓存，不同SqlSession之间的缓存数据互不影响。
二级缓存是mapper的同namespace级别的缓存，操作同一个mapper的不同SqlSession可以公用二级缓存。

**失效场景：**
一级缓存：
1、SqlSession执行增、删、改这些变数据的操作，会清空一级缓存。
2、调用SqlSession对象的clearCache方法
3、调用SqlSession对象的close方法
4、SqlSession是线程不安全的，因为jdbc操作本身线程不安全，在多线程场景下，比如单机多线程或者分布式部署，都可能出现脏读。
二级缓存：
1、二级缓存默认不开启，不生效。需要手动开启。
2、二级缓存有过期时间，默认1小时
3、同一namespace下进行增、删、改操作，缓存被清除。
4、分布式部署的时候，二级缓存使用默认实现类会出现脏读，应当使用分布式缓存。

####5、简述Mybatis的插件运行原理，以及如何编写一个插件？
**运行原理：**
总的来说，运行原理是用jdk动态代理实现的，使用了面向切面编程的思想。
在mybatis四大组件（Executor、StatementHandler、ParameterHandler、ResultSetHandler）创建时，不是直接返回的，而是返回一个代理对象。调用拦截器链中的拦截器依次对目标进行拦截或增强。
对mybatis来说，插件就是拦截器。Plugin实现了InvocationHandler，所以在invoke方法对被拦截的方法进行了前置或者后置增强。
invoke方法会检测被拦截的方法是否配置在插件的@Signature注解中，若是，执行插件逻辑，否则直接执行被拦截方法。插件逻辑封装在intercept方法中，前置或者后置增强后，执行被拦截的方法。

**自定义插件步骤：**
1、创建自定义插件实现类，重写它的方法。
intercept方法：自定义增强的方法写在这里。
plugin方法：把当前的拦截器生成代理存到拦截器链当中。
setProperties方法：设置配置文件的参数
并指定拦截哪个核心对象和对象中的哪个方法。使用@Intercepts注解和@Signature注解，type属性指定拦截哪个接口，method属性指定拦截哪个方法。
2、在sqlMapconfig.xml中注册自定义插件，使用plugins和plugin标签